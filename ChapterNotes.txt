Chapter 1 --> Arrays and Strings

Hash Table --> A hash table is a data structure that maps keys to values for highly efficient lookup. 
   A simple implementation example, we use an array of linked lists and a hash code function.
   1. Compute hash code for "Keys". (note: two different key can have same hash code)
   2. Map hash code with index of array using some approach {example, hash(key) % array_length}
   3. At every index there will be linked list of keys and values.

   Hence, To retrieve the value pair by its key, you repeat this process. Compute the hash code from the key, and then
   compute the index from the hash code. Then, search through the linked list for the value with this key.

   The worst case runtime is O(N), where N is the number of keys. This could be because of high collision for two different keys with the same hash code, or two different hash codes that map to the same index.
   A good implementation that keeps collisions to a minimum would have runtime O(1).

   Alternative approach is hash table with a balanced binary search tree, runtime would be O (log N). The advantage is potentially using less space, as no need of large Array and iteration over keys can be in ordered in somecases.

--> Arraylist / Resizable Array --> An Arraylist is resizable array, while still providing O(1) runtime access. A typical implementation
is that when the array is full, the array doubles in size. Each doubling takes 0(N) time, but happens so rarely that its amortized insertion time is still  O(1). "resizing factor" can be different in different languages.

** very imp data structure for interview.

--> StringBuilder --> concatenating a list of strings
On each concatenation, a new copy of the string is created, and the two strings are copied over, character by character.
The total time therefore is O(x + 2x + . . . + nx). This reduces to O(xn2).

Why is it O(xn2)? --> Because 1 + 2 + ... + n equals n(n+1)/2, or O(n2).

--> StringBuilder can help you avoid.this problem. StringBuilder simply creates a resizable array of all the strings, copying them back to a string only when necessary.

A good exercise to practice strings, arrays, and general data structures is to implement your own version of
StringBuilder, HashTable and Array List.

Additional Reading: Hash Table Collision Resolution (pg 636), Rabin-Karp Substring Search (pg 636).

Ch 2 --> Linked List 

Linked list represent sequence of Nodes. 
Single linked list --> each node point to next node in the list
Doubly LL --> each node points to both next node and previous node in the list.

No constant time element access in LL. means, to find Kth element we need to iterate through K element.
Hence, time constant is O(N), but space constant is O(1) {Need to check this concept}.

Benefit of LL --> you can add and remove items from the begining of LL in constant time. This is useful for many specific applications.

Important thing to remember ---> 1. to check for NULL pointer, 2. to update the head or tail pointer as necessary

Runner Technique in Linked list --> Use of two pointers simultaneously to iterate through list and these pointers are dependent on each other. (for example, one pointer moves one step forward and hence the other pointer moves 2 steps forward.)

Recursive LL approach --> This approach takes O(N) space, where N is depth of recursive call.
Recursive algorithm means, making a call iteratively.

Chapter 3 --> Stacks and Queues

Stacks --> stack data structure is precisely what it sounds like: a stack of data.
A stack uses LIFO (last-in first-out) ordering. similar to, a stack of dinner plates.
In certain types of problems, it can be favorable to store data in a stack rather than in an array.

It uses the following operations:
pop ( ) : Remove the top item from the stack.
push ( i tern): Add an item to the top of the stack.
peek(): Return the top of the stack.
is Empty (): Return true if and only if the stack is empty.

Unlike an array, a stack does not offer constant-time access to the i th item. However, it does allow constant time adds and removes, as it doesn't require shifting elements around.

A stack can be implemented using a linked list or an arraylist.
** Stacks are mostly useful for recursive algorithms. 

Queue --> A queue implements FIFO (first-in first-out) ordering. (example, same as a line or queue at a ticket stand)
It uses the operations:
add ( i tern): Add an item to the end of the list.
remove (): Remove the first item in the list.
peek ( ) : Return the top of the queue.
is Empty(): Return true if and only if the queue is empty.

A queue can also be implemented with a linked list. In fact, they are essentially the same thing, as long as items are added and removed from opposite sides.

**** It is especially easy to mess up the updating of the first and last nodes in a queue. Be sure to double check this.

** queues are often used is in breadth-first search or in implementing a cache.

Chapter 4 --> Trees and Graphs
Searching a tree is more complicated than searching in a linearly organized data structure such as an array or linked list.
Additionally, the worst case and average case time may vary wildly, and we must evaluate both aspects of any algorithm.
you must learn it to become fluent in this.

Trees / Type of Trees -->  A Tree is actually a type of Graph.
A tree is a data structure composed of nodes. Below is common scenario of a tree:

1. Each tree has a root node. (Actually, this isn't strictly necessary in graph theory, but it's usually how we use trees in programming, and especially programming interviews.)
2. The root node has zero or more child nodes.
3. Each child node has zero or more child nodes, and so on.

The tree cannot contain cycles. The nodes may or may not be in a particular order, they could have any data type as values, and they may or may not have links back to their parent nodes. 

Tree and graph questions are very common with ambiguous details and incorrect assumptions. Be sure to watch out and check details.

Tree vs Binary Tree --> 
A binary tree is a tree in which each node has up to two children. Not all trees are binary trees.
If a tree has three child node than that becomes ternary tree.
it can be even more, For example, suppose you were using a tree to represent a bunch of phone numbers. In this case, you might use a 10-ary tree, with each node having up to 10 children (one for each digit).

** A node is called a "leaf" node if it has no children.

Binary Tree vs. Binary Search Tree --> 
A binary search tree is a binary tree in which every node fits a specific ordering property: all left descendents <= n < all right descendents. This must be true for each node n.

**** The definition of a binary search tree can vary slightly with respect to equality. Under some definitions, the tree cannot have duplicate values. In others, the duplicate values will be on the right or can be on either side. All are valid definitions, but you should clarify this with your interviewer.

Hence, A binary search tree imposes the condition that, for each node, its left descendents are less than or equal to the current node, which is less than the right descendents.

Balanced vs. Unbalanced --> Not all trees are always balanced. Make sure about this in your question.


