Chapter 1 --> Arrays and Strings

Hash Table --> A hash table is a data structure that maps keys to values for highly efficient lookup. 
   A simple implementation example, we use an array of linked lists and a hash code function.
   1. Compute hash code for "Keys". (note: two different key can have same hash code)
   2. Map hash code with index of array using some approach {example, hash(key) % array_length}
   3. At every index there will be linked list of keys and values.

   Hence, To retrieve the value pair by its key, you repeat this process. Compute the hash code from the key, and then
   compute the index from the hash code. Then, search through the linked list for the value with this key.

   The worst case runtime is O(N), where N is the number of keys. This could be because of high collision for two different keys with the same hash code, or two different hash codes that map to the same index.
   A good implementation that keeps collisions to a minimum would have runtime O(1).

   Alternative approach is hash table with a balanced binary search tree, runtime would be O (log N). The advantage is potentially using less space, as no need of large Array and iteration over keys can be in ordered in somecases.

--> Arraylist / Resizable Array --> An Arraylist is resizable array, while still providing O(1) runtime access. A typical implementation
is that when the array is full, the array doubles in size. Each doubling takes 0(N) time, but happens so rarely that its amortized insertion time is still  O(1). "resizing factor" can be different in different languages.

** very imp data structure for interview.

--> StringBuilder --> concatenating a list of strings
On each concatenation, a new copy of the string is created, and the two strings are copied over, character by character.
The total time therefore is O(x + 2x + . . . + nx). This reduces to O(xn2).

Why is it O(xn2)? --> Because 1 + 2 + ... + n equals n(n+1)/2, or O(n2).

--> StringBuilder can help you avoid.this problem. StringBuilder simply creates a resizable array of all the strings, copying them back to a string only when necessary.

A good exercise to practice strings, arrays, and general data structures is to implement your own version of
StringBuilder, HashTable and Array List.

Additional Reading: Hash Table Collision Resolution (pg 636), Rabin-Karp Substring Search (pg 636).

Ch 2 --> Linked List 

Linked list represent sequence of Nodes. 
Single linked list --> each node point to next node in the list
Doubly LL --> each node points to both next node and previous node in the list.

No constant time element access in LL. means, to find Kth element we need to iterate through K element.
Hence, time constant is O(N), but space constant is O(1) {Need to check this concept}.

Benefit of LL --> you can add and remove items from the begining of LL in constant time. This is useful for many specific applications.

Important thing to remember ---> 1. to check for NULL pointer, 2. to update the head or tail pointer as necessary

Runner Technique in Linked list --> Use of two pointers simultaneously to iterate through list and these pointers are dependent on each other. (for example, one pointer moves one step forward and hence the other pointer moves 2 steps forward.)

Recursive LL approach --> This approach takes O(N) space, where N is depth of recursive call.
Recursive algorithm means, making a call iteratively.

Chapter 3 --> Stacks and Queues

Stacks --> stack data structure is precisely what it sounds like: a stack of data.
A stack uses LIFO (last-in first-out) ordering. similar to, a stack of dinner plates.
In certain types of problems, it can be favorable to store data in a stack rather than in an array.

It uses the following operations:
pop ( ) : Remove the top item from the stack.
push ( i tern): Add an item to the top of the stack.
peek(): Return the top of the stack.
is Empty (): Return true if and only if the stack is empty.

Unlike an array, a stack does not offer constant-time access to the i th item. However, it does allow constant time adds and removes, as it doesn't require shifting elements around.

A stack can be implemented using a linked list or an arraylist.
** Stacks are mostly useful for recursive algorithms. 

Queue --> A queue implements FIFO (first-in first-out) ordering. (example, same as a line or queue at a ticket stand)
It uses the operations:
add ( i tern): Add an item to the end of the list.
remove (): Remove the first item in the list.
peek ( ) : Return the top of the queue.
is Empty(): Return true if and only if the queue is empty.

A queue can also be implemented with a linked list. In fact, they are essentially the same thing, as long as items are added and removed from opposite sides.

**** It is especially easy to mess up the updating of the first and last nodes in a queue. Be sure to double check this.

** queues are often used is in breadth-first search or in implementing a cache.

Chapter 4 --> Trees and Graphs
Searching a tree is more complicated than searching in a linearly organized data structure such as an array or linked list.
Additionally, the worst case and average case time may vary wildly, and we must evaluate both aspects of any algorithm.

